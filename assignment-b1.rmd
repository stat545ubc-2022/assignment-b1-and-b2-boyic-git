---
title: "Assignment B2"
output: github_document
---

## Setup
```{r, message = FALSE}
library(datateachr) 
library(tidyverse)
```

## Exercise 1 & 2
In this assignment, I want to create a function that create a new categorical 
variable with `n` categories using a numerical variable by dividing the range of 
that variable into `n` equal parts. The original code is as follows:
```{r}
sample_area_range <- max(cancer_sample$area_mean) - min(cancer_sample$area_mean)
(new_cancer_sample <- cancer_sample %>% 
   mutate(size = case_when(area_mean < sample_area_range / 3 ~ "Small",
                           area_mean < sample_area_range*2/3 ~ "Mid",
                           area_mean >= sample_area_range*2/3 ~ "Large"),
          .after = diagnosis))
```

The function should take a table, a variable name of the column that is to be 
grouped, a variable name to be used for the new column and a vector of category 
names. It should output a new table with a new column with a name is requested 
in the input. I call this function `group_into`.
```{r}
#' Adding a new categorical column into the table 
#' 
#' This function will create a new table that includes the original table and a 
#' new column which is a categorical variable with values depending on the values 
#' requested by the user.
#'
#' @param table original table need to be modified (it makes sense to name the 
#` variable simple like a single word "table")
#' @param source_name name of the column to be categorized (the name is intuitive)
#' @param new_name name of the new column which has categorized values (the name 
#` is intuitive)
#' @param categories a vector of categories, it needs to be in ascending order
#`(because the element in the vector is a category so I take the plural form)
#'
#' @return the table with a new categorical column
#' @export
#'
#' @examples 
#' new_cancer_sample <- group_into(cancer_sample, "area_mean", "area", c("Small", "Medium", "Large"))
group_into <- function(table, source_name, new_name, categories) {
  # check if source_name in the table
  stopifnot(source_name %in% colnames(table))
  
  # check length of categories is greater than 0
  stopifnot(length(categories) > 0)
  
  # group the samples depending on the value of source_name 
  new_table <- table
  new_table[, new_name] <- cut(table[[source_name]], breaks = length(categories), labels = categories)
  
  return(new_table)
}
```
## Exercise 3 - Examples
Working examples of group using the `cancer_sample` dataset
```{r, error=TRUE}
# working example using the `cancer_sample` dataset
(aream_cancer_sample_using_function <- group_into(cancer_sample, "area_mean", 
                                               "area", 
                                               c("Small", "Medium", "Large")))

(compactness_cancer_sample_using_function <- group_into(cancer_sample, "compactness_mean", 
                                               "compactness", 
                                               c("non-compact", "compact")))
```

A failed example because I do not provide correct source column name
```{r, error=TRUE}
group_into(cancer_sample, "area_mean_not_existing", "area", c("Small", "Medium", "Large"))
```

A failed example because I provide a empty catogory
```{r, error=TRUE}
group_into(cancer_sample, "area_mean", "area", c())
```

## Exercise 4
```{r}
library(testthat)

test1 <- group_into(cancer_sample, "area_mean", "area", c("Small", "Medium", "Large"))


test_that("Exercise 4 test", {
          expect_equal(as.character(test1$area[1]), "Medium")
          expect_error(group_into(cancer_sample, "area_mean_not_existing", "area", c("Small", "Medium", "Large")))
          expect_error(group_into(cancer_sample, "area_mean", "area", c())) # empty vector
          })
```


